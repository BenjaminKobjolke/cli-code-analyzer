"""PHP-CS-Fixer analyze rule for PHP code style checking"""

import csv
import json
import re
from pathlib import Path

from models import LogLevel, Severity, Violation
from rules.base import BaseRule
from settings import Settings

# Default paths to exclude if none specified
DEFAULT_EXCLUDE_PATHS = ['vendor', '.git']

# Config file names in order of priority
FIXER_CONFIG_FILES = ['.php-cs-fixer.dist.php', '.php-cs-fixer.php']


class PHPCSFixerAnalyzeRule(BaseRule):
    """Rule to analyze PHP code style using PHP-CS-Fixer in dry-run mode"""

    def __init__(self, config: dict, base_path: Path | None = None, output_folder: Path | None = None, log_level: LogLevel = LogLevel.ALL, max_errors: int | None = None, rules_file_path: str | None = None):
        super().__init__(config=config, base_path=base_path, log_level=log_level, max_errors=max_errors, rules_file_path=rules_file_path)
        self.output_folder = output_folder
        self.log_level = log_level
        self.settings = Settings()
        self._fixer_executed = False

    def _get_bundled_fixer_path(self) -> str | None:
        """Get PHP-CS-Fixer path from bundled php/vendor/bin folder."""
        script_dir = Path(__file__).parent.parent
        paths = [
            script_dir / 'php' / 'vendor' / 'bin' / 'php-cs-fixer.bat',
            script_dir / 'php' / 'vendor' / 'bin' / 'php-cs-fixer',
        ]
        for p in paths:
            if p.exists():
                return str(p)
        return None

    def _get_exclude_paths(self) -> list[str]:
        """Get exclude paths from config, with defaults if not specified."""
        if isinstance(self.config, str):
            return DEFAULT_EXCLUDE_PATHS.copy()
        return self.config.get('exclude_paths', DEFAULT_EXCLUDE_PATHS.copy())

    def _get_rules(self) -> str:
        """Get rules from config."""
        if isinstance(self.config, str):
            return self.config
        return self.config.get('rules', '@PSR12')

    def _is_managed(self) -> bool:
        """Check if config file management is enabled (default: True)."""
        if isinstance(self.config, str):
            return True
        return self.config.get('managed', True)

    def _get_fixer_config_path(self) -> Path | None:
        """Find existing PHP-CS-Fixer config file in the project."""
        for config_name in FIXER_CONFIG_FILES:
            config_path = self.base_path / config_name
            if config_path.exists():
                return config_path
        return None

    def _parse_fixer_config_excludes(self, config_content: str) -> list[str]:
        """Parse exclude paths from existing PHP-CS-Fixer config file.

        Looks for patterns like:
            ->exclude(['vendor', 'storage'])
            ->exclude(["vendor", "storage"])
        """
        excludes = []
        # Match ->exclude([...]) with single or double quotes
        pattern = r"->exclude\s*\(\s*\[(.*?)\]\s*\)"
        match = re.search(pattern, config_content, re.DOTALL)
        if match:
            items_str = match.group(1)
            # Extract quoted strings
            items = re.findall(r"['\"]([^'\"]+)['\"]", items_str)
            excludes.extend(items)
        return excludes

    def _generate_fixer_config(self, exclude_paths: list[str], rules: str) -> str:
        """Generate PHP-CS-Fixer config file content."""
        # Use forward slashes for PHP (works on all platforms)
        exclude_list = ", ".join(f"'{p}'" for p in exclude_paths)

        return f'''<?php
// Auto-generated by cli-code-analyzer
// Modify exclude_paths in code_analysis_rules.json and re-run to update
// Set "managed": false in your config to prevent auto-updates

$finder = PhpCsFixer\\Finder::create()
    ->in(__DIR__)
    ->exclude([{exclude_list}]);

return (new PhpCsFixer\\Config())
    ->setRules(['{rules}' => true])
    ->setFinder($finder);
'''

    def _create_fixer_config(self, exclude_paths: list[str], rules: str) -> Path:
        """Create a new PHP-CS-Fixer config file."""
        config_path = self.base_path / '.php-cs-fixer.dist.php'
        content = self._generate_fixer_config(exclude_paths, rules)
        config_path.write_text(content, encoding='utf-8')
        print(f"  Created config: {config_path.name}")
        return config_path

    def _update_fixer_config(self, config_path: Path, exclude_paths: list[str], rules: str) -> bool:
        """Update existing PHP-CS-Fixer config file if excludes don't match.

        Returns True if config was updated, False if no update needed.
        """
        try:
            content = config_path.read_text(encoding='utf-8')
            current_excludes = self._parse_fixer_config_excludes(content)

            # Check if excludes match (order doesn't matter)
            if set(current_excludes) == set(exclude_paths):
                return False

            # Update the config file
            new_content = self._generate_fixer_config(exclude_paths, rules)
            config_path.write_text(new_content, encoding='utf-8')
            print(f"  Updated config: {config_path.name}")
            print(f"    Old excludes: {current_excludes}")
            print(f"    New excludes: {exclude_paths}")
            return True

        except Exception as e:
            print(f"  Warning: Could not update config {config_path.name}: {e}")
            return False

    def _ensure_fixer_config(self) -> Path | None:
        """Ensure PHP-CS-Fixer config exists with correct exclude paths.

        Returns the path to the config file, or None if management is disabled.
        """
        if not self._is_managed():
            existing = self._get_fixer_config_path()
            if existing:
                print(f"  Using existing config: {existing.name} (managed=false)")
            return existing

        exclude_paths = self._get_exclude_paths()
        rules = self._get_rules()

        existing_config = self._get_fixer_config_path()

        if existing_config:
            # Check and update if needed
            self._update_fixer_config(existing_config, exclude_paths, rules)
            return existing_config
        else:
            # Create new config
            return self._create_fixer_config(exclude_paths, rules)

    def check(self, _file_path: Path) -> list[Violation]:
        """Run PHP-CS-Fixer check in dry-run mode on the entire project (only once)."""
        if self._fixer_executed:
            return []

        self._fixer_executed = True
        print("\nRunning PHP-CS-Fixer check...")

        # First check bundled php/vendor/bin folder
        fixer_path = self._get_bundled_fixer_path()
        if not fixer_path:
            fixer_path = self._get_tool_path('php-cs-fixer', self.settings.get_php_cs_fixer_path, self.settings.prompt_and_save_php_cs_fixer_path)
        if not fixer_path:
            return []

        violations = self._run_fixer_check(fixer_path)
        return violations

    def _run_fixer_check(self, fixer_path: str) -> list[Violation]:
        """Execute PHP-CS-Fixer in dry-run mode and parse results."""
        # Ensure config file exists with correct exclude paths
        config_path = self._ensure_fixer_config()

        # Get analysis path
        if isinstance(self.config, str):
            analyze_path = str(self.base_path)
        else:
            analyze_path = self.config.get('analyze_path', str(self.base_path))

        # Resolve relative path
        if not Path(analyze_path).is_absolute():
            analyze_path = str(self.base_path / analyze_path)

        # Build command
        cmd = [fixer_path, 'fix', '--dry-run', '--format=json', '--verbose', '--show-progress=none', '--no-interaction']

        # Use config file if available, otherwise use --rules
        if config_path:
            cmd.extend(['--config', str(config_path)])
        else:
            rules = self._get_rules()
            if rules:
                cmd.extend(['--rules', rules])

        # Add path to analyze
        cmd.append(analyze_path)

        # Print scanning info
        exclude_paths = self._get_exclude_paths()
        rules = self._get_rules()
        print(f"  Scanning: {analyze_path}")
        print(f"  Excluding: {', '.join(exclude_paths)}")
        print(f"  Rules: {rules}")

        try:
            result = self._run_subprocess(cmd, self.base_path)
            output = result.stdout

            # Show stderr for progress info (PHP-CS-Fixer outputs progress there)
            if result.stderr and 'legend:' not in result.stderr.lower():
                # Filter out the legend and empty lines, show actual progress
                stderr_lines = [l for l in result.stderr.strip().split('\n')
                               if l.strip() and 'legend:' not in l.lower() and l.strip() != '.']
                if stderr_lines:
                    for line in stderr_lines[:5]:  # Show first few lines of progress
                        print(f"  {line}")

            violations = self._parse_fixer_json(output)
            violations = self._filter_violations_by_log_level(violations)

            if self.max_errors and len(violations) > self.max_errors:
                violations = violations[:self.max_errors]

            if violations:
                print(f"PHP-CS-Fixer found {len(violations)} issue(s)")
            else:
                print("PHP-CS-Fixer: No issues found")

            if self.output_folder and violations:
                output_file = self.output_folder / 'php_cs_fixer.csv'
                self._write_csv_output(output_file, output)

            return violations

        except FileNotFoundError:
            print(f"Error: PHP-CS-Fixer executable not found: {fixer_path}")
            print("Please ensure PHP-CS-Fixer is installed: composer require --dev friendsofphp/php-cs-fixer")
            return []
        except Exception as e:
            print(f"Error running PHP-CS-Fixer check: {e}")
            return []

    def _parse_fixer_json(self, output: str) -> list[Violation]:
        """Parse PHP-CS-Fixer JSON output into violations.

        PHP-CS-Fixer JSON format:
        {
            "files": [
                {
                    "name": "path/to/file.php",
                    "appliedFixers": ["braces", "indentation_type", ...]
                }
            ]
        }
        """
        violations = []

        if not output or not output.strip():
            return violations

        try:
            data = json.loads(output)
            files = data.get('files', [])

            for file_info in files:
                file_path = file_info.get('name', 'unknown')
                fixers = file_info.get('appliedFixers', [])

                try:
                    rel_path = self._get_relative_path(Path(file_path))
                except Exception:
                    rel_path = file_path

                # Create one violation per file listing all fixers that would be applied
                if fixers:
                    fixer_list = ', '.join(fixers)
                    message = f"Code style issues found. Would apply fixers: {fixer_list}"

                    violation = Violation(
                        file_path=rel_path,
                        rule_name='php_cs_fixer',
                        severity=Severity.WARNING,
                        message=message
                    )
                    violations.append(violation)

        except json.JSONDecodeError as e:
            print(f"Error parsing PHP-CS-Fixer JSON output: {e}")
            print(f"Output was: {output[:200]}...")
        except Exception as e:
            print(f"Error processing PHP-CS-Fixer results: {e}")

        return violations

    def _write_csv_output(self, output_file: Path, json_content: str):
        """Write PHP-CS-Fixer results to CSV file."""
        try:
            data = json.loads(json_content)
            files = data.get('files', [])

            if not files:
                return

            all_violations = []

            for file_info in files:
                file_path = file_info.get('name', 'unknown')
                fixers = file_info.get('appliedFixers', [])

                try:
                    rel_path = self._get_relative_path(Path(file_path))
                except Exception:
                    rel_path = file_path

                if fixers:
                    all_violations.append({
                        'file': rel_path,
                        'severity': 'warning',
                        'fixers': ', '.join(fixers),
                        'fixer_count': len(fixers)
                    })

            # Apply max_errors limit
            if self.max_errors and len(all_violations) > self.max_errors:
                all_violations = all_violations[:self.max_errors]

            if not all_violations:
                return

            with open(output_file, 'w', encoding='utf-8', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['file', 'severity', 'fixers', 'fixer_count'])

                for v in all_violations:
                    writer.writerow([v['file'], v['severity'], v['fixers'], v['fixer_count']])

            print(f"PHP-CS-Fixer report saved to: {output_file}")

        except json.JSONDecodeError as e:
            print(f"Error parsing JSON for CSV output: {e}")
        except Exception as e:
            print(f"Error writing PHP-CS-Fixer CSV file: {e}")
